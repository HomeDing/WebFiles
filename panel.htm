<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Element Panel</title>
  <link href="/iotstyle.css" rel="stylesheet" type="text/css">

  <!-- https://necolas.github.io/normalize.css/ -->
  <!-- https://milligram.io/#grids -->
  <!-- https://www.sitepoint.com/how-to-translate-from-dom-to-svg-coordinates-and-back-again/ -->

  <script src="micro.js"></script>
  <script src="panel.js"></script>

  <!-- <script src="https://cdn.jsdelivr.net/npm/es6-promise@4/dist/es6-promise.auto.js"></script> -->
  <script src="es6-promise.auto.js"></script>
  <script src="polyfill.js"></script>

  <style>
    #panel {
      background-color: #f8f8f8;
    }

    #panel #templates {
      display: none;
    }

    #links>line {
      stroke: #080808;
      stroke-width: 2;
      stroke-linecap: round;
    }

    .node rect {
      fill: #d4dced;
      stroke-width: 0;
    }

    .node {
      font-size: 12px;
      font-family: sans-serif;
      fill: #000000;
      fill-opacity: 1;
      stroke: none;
      font-style: normal;
      font-weight: normal;
    }

    .node circle {
      fill: #505050;
      stroke-width: 0;
    }

    .node text {
      font-size: 10px;
    }

    #Grid {
      fill: #e0e0e0;
      stroke: none
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="u-header">
      <a href="/"><img class="icon" src="/favicon.svg" /></a>
      <h1>Panel</h1>
      <a href="/ding-ide.htm"><img class="icon" src="/i/ide.svg" /></a>
      <a href="/ding-ide.htm" class="hidden-xs">IDE</a>
    </div>
    <div class="u-navbar">
      <button id="moveButton">move</button>
    </div>

    <svg id="panel">
      <defs>
        <pattern id="Grid" height="72" width="72" patternUnits="userSpaceOnUse">
          <path d="m0,0h8v1h-7v7h-1z" />
        </pattern>
      </defs>
      <rect fill="url(#Grid)" height="100%" width="100%"></rect>
  
        <g id="templates">
          <g dragabble="true" class="node">
            <rect width="64" height="64" rx="8"></rect>
            <image class="icon" x="16" y="4" width="32" height="32" xlink:href="/i/default.svg" />
            <text class="id" x="32" y="56" text-anchor="middle">subtitle</text>
            <circle pin="in" cx="8" cy="36" r="6"></circle>
            <circle pin="out" cx="56" cy="36" r="6"></circle>
          </g>
        </g>
        <g id="viewport">
          <g id="nodes"></g>
          <g id="links"></g>
        </g>
      </svg>

    <script>
      var PANEL_GRIDSIZE = 72; // px
      var PANEL_WIDTH = 12;
      var PANEL_HEIGHT = 8;

      var panelObj = document.getElementById('panel');
      var viewObj = document.getElementById('viewport');
      var moveButtonObj = document.getElementById('moveButton');

      panelObj.style.width = PANEL_GRIDSIZE * PANEL_WIDTH + "px";
      panelObj.style.height = PANEL_GRIDSIZE * PANEL_HEIGHT + "px";

      var DragObj = null;
      var DragOffset = null;

      var nodes = {};
      var links = [];

      // find the position of the pin of a node.
      function _pinPos(node, pin) {
        var panelPos = panelObj.getBoundingClientRect();

        var obj = node.obj.querySelector('[pin="' + pin + '"]');
        if (!obj)
          obj = node.obj;

        var b2 = obj.getBoundingClientRect();

        var pos = {
          x: Math.round(b2.left + b2.width / 2 - panelPos.left),
          y: Math.round(b2.top + b2.height / 2 - panelPos.top)
        };
        return (pos);
      } // _pinPos()


      // create all links from the actions of nodes.
      function createLinks(srcPath, actions) {
        actions.split(',').forEach(function (a) {
          var tarPath = a.split('?')[0];
          links.push({
            src: srcPath,
            srcPin: "out",
            tar: tarPath,
            tarPin: "in"
          });
        });
      }


      // create all nodes from the HomeDing config file
      function createNodes(json) {
        var px = 0;
        var py = 1;
        jsonParse(json, function (path, key, val) {
          if (path.split('/').length == 3) {
            path = path.substr(1);
            var n = nodes[path];
            if (!n) {
              n = nodes[path] = {}; // create a new node
              n.icon = path.split('/')[0];
            } // if
            if (key) {
              n[key] = val;
              if (key.substr(0, 2) == 'on') {
                createLinks(path, val);
              }
            } // if
          } // if
        });
        // remove links into nirvana
        links = links.filter(function (l) {
          return (nodes[l.src] && nodes[l.tar]);
        });
        // find nodes without links:
        p = 0;
        for (n in nodes) {
          nodes[n]._out = nodes[n]._in = 0;
        }
        links.forEach(function (l) {
          nodes[l.src]._out++;
          nodes[l.tar]._in++;
        });
        for (n in nodes) {
          if (nodes[n]._out == 0 && nodes[n]._in == 0) {
            // nodes without links in line 1:
            nodes[n].xPos = px++;
            nodes[n].yPos = 0;
          } else {
            // nodes with links vertically;
            nodes[n].xPos = 5 + nodes[n]._in - nodes[n]._out;
            nodes[n].yPos = py++;
          }
        };
      } // createNodes()

      function moveNodes() {
        links.forEach(function (l) {
          var sObj = nodes[l.src];
          var tObj = nodes[l.tar];
          // debugger;
          // sObj.xPos--;
          // tObj.xPos++;

        });

      }


      // update svg objects for all nodes
      function updateNodes() {
        for (var nodeId in nodes) {
          var e = nodes[nodeId];
          var obj = e.obj;
          if (!obj) {
            // create a new svg object for node
            var nodesObj = document.getElementById('nodes');
            var t = document.querySelector('#templates .node');
            obj = e.obj = t.cloneNode(true);
            nodesObj.appendChild(obj);
          }

          // update svg object by node properties
          if (e.icon)
            obj.querySelector('.icon').setAttribute("xlink:href", "/i/" + e.icon + ".svg");
          obj.querySelector('.id').firstChild.textContent = nodeId;

          moveSVGGroup(obj, e.xPos * PANEL_GRIDSIZE, e.yPos * PANEL_GRIDSIZE);
        } // for
      } // updateNodes()


      function updateLinks() {
        var aPos;

        for (var n = 0; n < links.length; n++) {
          var f = links[n];
          var sObj = nodes[f.src];
          var tObj = nodes[f.tar];

          if (sObj && tObj) {
            var obj = f.obj;
            if (!obj) {
              var linksObj = document.getElementById('links');
              obj = f.obj = linksObj.ownerDocument.createElementNS("http://www.w3.org/2000/svg", 'line');
              linksObj.appendChild(obj);
            } // if
            aPos = _pinPos(sObj, f.srcPin);
            obj.setAttribute("x1", aPos.x);
            obj.setAttribute("y1", aPos.y);

            aPos = _pinPos(tObj, f.tarPin);
            obj.setAttribute("x2", aPos.x);
            obj.setAttribute("y2", aPos.y);
          } // for
        }
      } // updateLinks()

      fetch('/config.json')
        .then(function (result) {
          return (result.json())
        }).then(function (json) {
          createNodes(json);
          moveNodes();
          updateNodes();
          updateLinks();
        });


      moveButtonObj.addEventListener("click", function () {
        nodes['time/0'].xPos++;
        updateNodes();
        updateLinks();
      })

      panelObj.addEventListener("mousedown", function (evt) {
        if (!DragObj) {
          var o = evt.target;
          // check for a draggable object.
          while (o && o.attributes && (!o.attributes["dragabble"]))
            o = o.parentNode;
          if (o && o.attributes && (o.attributes["dragabble"]))
            DragObj = o;
        }

        if (DragObj) {
          // calculate Drag Offset = mouse position - drag object position
          DragOffset = getSVGPos(panelObj, evt);
          var cc = DragObj.getCTM();
          DragOffset.x -= cc.e;
          DragOffset.y -= cc.f;
        }
      }); // mouseDown


      panelObj.addEventListener("mousemove", function (evt) {
        if (DragObj) {
          var DragPos = getSVGPos(panelObj, evt);
          moveSVGGroup(DragObj, DragPos.x - DragOffset.x, DragPos.y - DragOffset.y);
          updateLinks();
        } // if
      }); // mousemove


      panelObj.addEventListener("mouseup", function (evt) {
        if (DragObj) {
          var DragPos = getSVGPos(panelObj, evt);

          for (var n in nodes) {
            if (nodes[n].obj == DragObj) {
              nodes[n].xPos = Math.floor(DragPos.x / PANEL_GRIDSIZE);
              nodes[n].yPos = Math.floor(DragPos.y / PANEL_GRIDSIZE);
              break;
            }
          } // for
          updateNodes();
          updateLinks();

          DragObj = null;
        } // if
      }); // mouseup


      var scrollSensitivity = 0.2
      panelObj.addEventListener("mousewheel", function (e) {
        // debugger;
        var cs = panelObj.currentScale;
        panelObj.setAttribute("transform", "scale(" + (cs + 0.2) + ")");
      });
    </script>


  </div>
</body>

</html>