<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Element Panel</title>
  <link href="/iotstyle.css" rel="stylesheet" type="text/css">

  <script src="micro.js"></script>
  <script src="microsvg.js"></script>
  <script src="panel.js"></script>

  <style>
    #panel {
      fill: none;
      background-color: silver;
      background-image: linear-gradient(to top, rgba(0, 0, 0, .2) 1px, transparent 1px),
        linear-gradient(to left, rgba(0, 0, 0, .2) 1px, transparent 1px);
      background-size: 72px 72px;
    }

    #panel #templates {
      display: none;
    }

    #links>line,
    #links>path {
      stroke: #080808;
      stroke-width: 3;
      stroke-linecap: round;
      marker-end: url(#arrow);
    }

    .node {
      font-size: 12px;
      font-family: sans-serif;
      fill: #000000;
      fill-opacity: 1;
      stroke: none;
      font-style: normal;
      font-weight: normal;
    }

    .node rect {
      fill: #d4dced;
      stroke-width: 0;
    }

    .node circle {
      fill: #505050;
      stroke-width: 0;
    }

    .node text {
      font-size: 10px;
    }

    #Grid {
      fill: #e0e0e0;
      stroke: none
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="row u-header">
      <h1>Panel</h1>
    </div>
    <div class="row u-navbar">
      <a class="button" href="/">Home</a>
      <a class="button" href="/board.htm">Board</a>
      <a class="button" href="/microide.htm">IDE</a>
      <a class="button" href="/log.htm">Log</a>
      <span class="gap"></span>
      <button id="sysButton">sys</button>
    </div>

    <div class="row" style="margin-top:0.5em;user-select: none;">
      <svg id="panel">
        <defs>
          <marker id="arrow" markerWidth="6" markerHeight="6" refX="16" refY="8" orient="auto" xmarkerUnits="strokeWidth" viewBox="0 0 16 16">
            <path d="M0,0 L0,16 L16,8 z" fill="currentColor" />
          </marker>
        </defs>
        <rect height="100%" width="100%"></rect>
        <g id="templates">
          <g dragabble="true" class="node">
            <title></title>
            <rect width="64" height="64" rx="8"></rect>
            <use class="icon" x="16" y="8" width="32" height="32" color="#203050" href="" />
            <use class="config" x="48" y="4" width="12" height="12" color="#203050" href="/icons.svg#config" />
            <text class="id" x="32" y="56" text-anchor="middle">subtitle</text>
            <circle pin="in" cx="8" cy="40" r="5"></circle>
            <circle pin="out" dragabble="true" cx="56" cy="40" r="5"></circle>
          </g>
        </g>
        <g id="viewport">
          <g id="nodes"></g>
          <g id="links"></g>
        </g>

        <g id="connect" style="fill:lime">
          <rect x=474 y=112 width="64" height="64" rx="8"></rect>
        </g>

      </svg>
    </div>
    <div id="errors" style="margin-top:0.5em;color:red">
    </div>
  </div>

  <script>
    // GRID dimension and size
    const PANEL_GRIDSIZE = 72; // px
    const PANEL_WIDTH = 16;
    const PANEL_HEIGHT = 12;

    // using localstorage to remember placing the elements.
    const XY = "uXY";

    var sysObj = document.getElementById('sysButton');

    var params = getHashParams({
      sys: false
    });
    window.addEventListener("hashchange", function () {
      window.location.reload();
    });
    sysObj.addEventListener('click', function (evt) {
      params.sys = !toBool(params.sys);
      window.location.hash = 'sys=' + params.sys;
    });

    async function loadPlugins() {
      var ret;
      if (!document.querySelector('dialog#addElement')) {
        // lazy load dialogs.
        ret = fetch("./board-new.htm")
          .then(res => res.text())
          .then(txt => {
            document.body.appendChild(document.createRange().createContextualFragment(txt));
          });
      }
      return (ret);
    } // loadPlugins()

    // initiate a fetch with JSON res expected.
    async function fetchJSON(url, options) {
      var p = fetch(url, options)
        .then(raw => raw.json());
      return (p)
    }

    // Element definitions and config+state of running elements
    const uElements = {
      defs: {},
      impl: [],
      env: {},
      config: {},
      state: {}
    }

    var panelObj = document.getElementById('panel');
    var linksObj = document.getElementById('links');
    var viewObj = document.getElementById('viewport');
    const connectObj = document.getElementById('panel');

    panelObj.style.width = PANEL_GRIDSIZE * PANEL_WIDTH + "px";
    panelObj.style.height = PANEL_GRIDSIZE * PANEL_HEIGHT + "px";

    var DragObj = null;
    var DragMode = null;
    var DragOffset = null;

    // nodes are all existing elements from the device configuration
    // extended by _x, _y
    var nodes = {};
    var edges = [];

    // create all edges from the actions of a node.
    function createEdges(srcPath, actions) {
      actions.split(',').forEach(function (a) {
        var tarPath = a.split('?')[0];
        edges.push({
          src: srcPath,
          srcPin: "out",
          tar: tarPath,
          tarPin: "in"
        });
      });
    } // createEdges()

    /*
    HomeDing config data model ->
      create nodes = {id, xPos, _y, onXXX, obj }
      create edges = {src, srcPin, tar, tarPin, obj}
    */

    // create all nodes and edges from the HomeDing config files
    function createNodes(conf) {
      jsonParse(conf, function (path, key, val) {
        if ((path.length > 1) && (path[0] === '/'))
          path = path.substring(1);
        var p = path.split('/');
        if (p.length >= 2) {
          var s = JSON.stringify(conf[p[0]][p[1]], null, 2)
          var t = p[0].toLowerCase();
          var id = t + '/' + p[1].toLowerCase();

          if (toBool(params.sys) || (!uElements.defs[t]) || (toBool(uElements.defs[t].sys) == false)) {
            var n = nodes[id];
            if (!n) {
              n = nodes[id] = {
                id: id
              }; // create a new node
              n.icon = t;
              n.conf = s;
            } // if
            if (key) {
              // n[key] = val;
              if (key.substring(0, 2) == 'on') {
                createEdges(id, val);
              }
            } // if
          } // if
        } // if
      });
    } // createNodes()


    // initial placement of all nodes
    function placeNodes() {
      var px = 0;
      var py = 1;

      // remove edge going into the nirvana
      edges = edges.filter(function (l) {
        const fits = (nodes[l.src] && nodes[l.tar]);
        if (!fits) {
          createHTMLElement(document.querySelector('#errors'), 'p')
            .textContent = `undeliverable action: ${l.src}->${l.tar}`;
        }
        return (fits);
      });

      // == find nodes without edges:

      // reset in/out counters to 0
      Object.values(nodes).forEach(v => { v._out = v._in = 0; });
      edges.forEach(l => {
        nodes[l.src]._out++;
        nodes[l.tar]._in++;
      });

      let locs = JSON.parse(window.localStorage.getItem(XY) || "{}");
      Object.entries(nodes).forEach(([key, value]) => {
        if (locs[key]) {
          value._x = locs[key]._x;
          value._y = locs[key]._y;
          value._fixed = true;

        } else if (value._out == 0 && value._in == 0) {
          // nodes without edges in line 1:
          value._x = px++;
          value._y = 0;

        } else {
          // nodes with edges vertically;
          value._x = 6 + value._in - value._out;
          value._x = Math.max(value._x, 0);
          value._y = py++;
        }
      });
    } // placeNodes()


    // return node that is placed on the grid at the (x/y) position.
    function posInUse(x, y) {
      const f = Object.values(nodes).find(o => {
        if ((o._x == x) && (o._y == y)) {
          return (o);
        }
      });
      return (f);
    } // posInUse()


    // return any node that is placed on the grid in line (y).
    function lineInUse(y) {
      var found = null;
      Object.values(nodes).forEach(function (o) {
        if ((!found) && (o._y == y))
          found = o;
      });
      return (found);
    };


    function yForce(nodeId) {
      var dist = 0;
      var num = 0;
      var _y = nodes[nodeId]._y;
      edges.forEach(function (l) {
        if (l.src == nodeId) {
          dist += nodes[l.tar]._y - _y;
          num++;
        }
        if (l.tar == nodeId) {
          dist += nodes[l.src]._y - _y;
          num++;
        }
      });
      return (dist / num);
    };


    function moveNodes() {
      var moved = false;

      // move according the force of connections
      for (var nodeId in nodes) {
        var node = nodes[nodeId];
        if (!(node._fixed)) {
          f = yForce(nodeId);
          if ((f < -0.5) && (!posInUse(node._x, node._y - 1))) {
            node._y--;
            moved = true;
          }
        }
      } // for

      // remove empty lines.
      for (var n = 0; n < 12; n++) {
        if (!lineInUse(n)) {
          for (var nodeId in nodes) {
            var e = nodes[nodeId];
            if (e._y === n + 1) {
              e._y--;
              moved = true;
            }
          } // for
        }
      }
      return (moved);
    } // moveNodes()


    function handleNode(id) {
      var moved = false;
      var n = nodes[id];
      var px = n._x;
      var py = n._y;
      var fx = 0;
      var fy = 0;

      if (!n._fixed) {
        // calculate force.
        edges.forEach(l => {
          if (l.src == id) {
            var tar = nodes[l.tar];
            if (tar._x - px < 2) fx -= 1; // keep min x distance
            if (tar._x - px > 2) fx += 1;
            if (tar._y < py) fy -= 1;
            if (tar._y > py) fy += 1;
          }
          if (l.tar == id) {
            var src = nodes[l.src];
            if (px - src._x < 2) fx += 1; // keep min x distance
            if (px - src._x > 2) fx -= 1;
            if (py < src._y) fy += 1;
            if (py > src._y) fy -= 1;
          }
        });
        if (fx > 0) px++;
        if (fx < 0) px--;
        if (fy > 0) py++;
        if (fy < 0) py--;
        if (!posInUse(px, py)) {
          n._x = px;
          n._y = py;
          drawNodes();
          drawEdges();
          moved = true;
        }
      }

      return (moved);
    } // handleNode


    // create / update svg objects for all nodes
    function drawNodes() {
      for (var nodeId in nodes) {
        var t = nodeId.split('/')[0];
        var e = nodes[nodeId];
        var ed = uElements.defs[t];

        var obj = e.obj;
        if (!obj) {
          // create a new svg object for node
          var nodesObj = document.getElementById('nodes');
          obj = e.obj = document.querySelector('#templates .node').cloneNode(true);
          nodesObj.appendChild(obj);
          obj.id = nodeId;
          // disable outgoing pin ?
          if (ed) {
            if ((ed.events) && (ed.events.length == 0)) {
              var pin = obj.querySelector('[pin="in"]');
              if (pin) pin.style.display = "none";
            }
            if ((ed.actions) && (ed.actions.length == 0)) {
              var pin = obj.querySelector('[pin="out"]');
              if (pin) pin.style.display = "none";
            }
          }

          obj.querySelector('.config').addEventListener('click', function (evt) {
            var t = evt.target;
            while (t && !t.classList.contains('node')) t = t.parentElement;
            // console.log(t.getAttribute('data'));
            const d = t.getAttribute('data');
            const id = t.getAttribute('id').split('/');
            DialogFormClass.openModalForm('configElement', { ...JSON.parse(d), type: id[0], id: id[1] });
          });
        }

        // update svg object by node properties
        if (e.icon)
          obj.querySelector('.icon').setAttribute("href", "/icons.svg#" + e.icon);
        if (e.conf)
          obj.querySelector('title').textContent = e.conf;
        obj.setAttribute("data", e.conf);
        obj.querySelector('.id').firstChild.textContent = nodeId;

        moveSVGGroup(obj, e._x * PANEL_GRIDSIZE + 4, e._y * PANEL_GRIDSIZE + 4);
      } // for

      // save pos
      const uPos = {};
      Object.values(nodes).forEach(n => {
        uPos[n.id] = { _x: n._x, _y: n._y }
      })
      window.localStorage.setItem(XY, JSON.stringify(uPos));
    } // drawNodes()


    // create / update all svg objects edges to current position of nodes
    function drawSingleEdge(obj, aPos, ePos) {
      if (!obj) {
        obj = linksObj.ownerDocument.createElementNS("http://www.w3.org/2000/svg", 'path');
        linksObj.appendChild(obj);
      } // if
      obj.setAttribute("d", `M ${aPos.x},${aPos.y} C ${aPos.x + 48},${aPos.y} ${ePos.x - 48},${ePos.y} ${ePos.x - 12},${ePos.y} L ${ePos.x},${ePos.y}`);
      return (obj);
    } // drawSingleEdge()


    // create / update all svg objects edges to current position of nodes
    function drawEdges() {
      var aPos, ePos;

      for (var n = 0; n < edges.length; n++) {
        var f = edges[n];
        var sObj = nodes[f.src];
        var tObj = nodes[f.tar];

        if (sObj && tObj) {
          var obj = f.obj;
          aPos = _pinPos(sObj, f.srcPin);
          ePos = _pinPos(tObj, f.tarPin);

          // spline version
          if (!obj) {
            obj = f.obj = linksObj.ownerDocument.createElementNS("http://www.w3.org/2000/svg", 'path');
            linksObj.appendChild(obj);
          } // if
          obj.setAttribute("d", `M ${aPos.x},${aPos.y} C ${aPos.x + 48},${aPos.y} ${ePos.x - 48},${ePos.y} ${ePos.x - 12},${ePos.y} L ${ePos.x},${ePos.y}`);
        } // for
      }
    } // drawEdges()

    // get configuration data
    var p2 = fetchJSON('/elements.json').then(json => uElements.defs = json);
    var p3 = fetchJSON('/env.json').then(json => uElements.env = json);
    var p4 = fetchJSON('/config.json').then(json => uElements.config = json);

    // start when all data is available
    Promise.all([p2, p3, p4]).then(function () {
      hub.write('env', JSON.stringify(uElements.env));
      hub.write('config', JSON.stringify(uElements.config));
      createNodes(uElements.env);
      createNodes(uElements.config);
      placeNodes();
      while (moveNodes()) { };

      var moveCnt = Object.keys(nodes).length * 2;
      var moved;
      do {
        moved = false;
        for (var nodeId in nodes) {
          moved = moved || handleNode(nodeId);
        } // for
        moveCnt--;
      } while (moved && moveCnt > 0);

      drawNodes();
      drawEdges();
      loadPlugins();
    });

    // === drag & drop

    var _conPos;
    var _conObj;


    panelObj.addEventListener("mousedown", function (evt) {
      if (!DragObj) {
        var o = evt.target;
        // check for a draggable object.
        while (o && o.attributes && (!o.attributes["dragabble"]))
          o = o.parentNode;
        if (o && o.attributes && (o.attributes["dragabble"]))
          DragObj = o;
      }

      if (DragObj) {
        if (DragObj.getAttribute('pin') === 'out') {
          DragMode = 'c';
          // create 
          DragOffset = getSVGPos(panelObj, evt);
          DragObj = createSVGNode(panelObj, 'circle', {
            cx: DragOffset.x,
            cy: DragOffset.y,
            r: 10,
            style: 'fill:lime'
          });
          _conPos = {x:DragOffset.x, y:DragOffset.y};
          _conObj = drawSingleEdge(undefined, _conPos, _conPos);
          console.log(_conPos);

        } else {
          DragMode = 'n';
          // calculate Drag Offset = mouse position - drag object position
          DragOffset = getSVGPos(panelObj, evt);
          var cc = DragObj.getCTM();
          DragOffset.x -= cc.e;
          DragOffset.y -= cc.f;
        }
      }
    }); // mouseDown


    panelObj.addEventListener("mousemove", function (evt) {
      if (DragObj) {
        var DragPos = getSVGPos(panelObj, evt);
        moveSVGGroup(DragObj, DragPos.x - DragOffset.x, DragPos.y - DragOffset.y);
        if (DragMode === 'n') {
          drawEdges();
        }
        else {
          drawSingleEdge(_conObj, _conPos, DragPos);
        }
      } // if
    }); // mousemove


    panelObj.addEventListener("mouseup", function (evt) {
      if (DragObj) {
        var DragPos = getSVGPos(panelObj, evt);

        for (var n in nodes) {
          if (nodes[n].obj == DragObj) {
            nodes[n]._x = Math.floor(DragPos.x / PANEL_GRIDSIZE);
            nodes[n]._y = Math.floor(DragPos.y / PANEL_GRIDSIZE);
            break;
          }
        } // for
        drawNodes();
        drawEdges();

        DragObj = null;
      } // if
    }); // mouseup

    if (window !== window.top) {
      // disable header and navbar in portal mode.
      document.querySelector('.u-header').style.display = 'none';
      document.querySelector('.u-navbar').style.display = 'none';
    } // if

  </script>
</body>

</html>